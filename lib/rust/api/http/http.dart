// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'http.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `DynamicResolver`, `StaticResolver`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `eq`, `fmt`, `from`, `resolve`, `resolve`

Future<RustHttpResponse> rustHttpRequest({required RustHttpRequest req}) =>
    RustLib.instance.api.crateApiHttpHttpRustHttpRequest(req: req);

class CustomProxy {
  final String url;
  final ProxyCondition condition;

  const CustomProxy({required this.url, required this.condition});

  @override
  int get hashCode => url.hashCode ^ condition.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CustomProxy &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          condition == other.condition;
}

class DnsSettings {
  final List<(String, List<String>)>? overrides;
  final String? fallback;
  final ArcFnStringDartFnFutureVecString? resolver;

  const DnsSettings({this.overrides, this.fallback, this.resolver});

  @override
  int get hashCode =>
      overrides.hashCode ^ fallback.hashCode ^ resolver.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DnsSettings &&
          runtimeType == other.runtimeType &&
          overrides == other.overrides &&
          fallback == other.fallback &&
          resolver == other.resolver;
}

enum Emulation {
  chrome100,
  chrome101,
  chrome104,
  chrome105,
  chrome106,
  chrome107,
  chrome108,
  chrome109,
  chrome110,
  chrome114,
  chrome116,
  chrome117,
  chrome118,
  chrome119,
  chrome120,
  chrome123,
  chrome124,
  chrome126,
  chrome127,
  chrome128,
  chrome129,
  chrome130,
  chrome131,
  chrome132,
  chrome133,
  chrome134,
  chrome135,
  chrome136,
  safariIos172,
  safariIos1741,
  safariIos165,
  safari153,
  safari155,
  safari1561,
  safari16,
  safari165,
  safari170,
  safari1721,
  safari1741,
  safari175,
  safari18,
  safariIPad18,
  safari182,
  safariIos1811,
  safari183,
  safari1831,
  okHttp39,
  okHttp311,
  okHttp313,
  okHttp314,
  okHttp49,
  okHttp410,
  okHttp412,
  okHttp5,
  edge101,
  edge122,
  edge127,
  edge131,
  edge134,
  firefox109,
  firefox117,
  firefox128,
  firefox133,
  firefox135,
  firefoxPrivate135,
  firefoxAndroid135,
  firefox136,
  firefoxPrivate136,
}

enum HttpVersionPref { http10, http11, http2, all }

enum ProxyCondition { http, https, all }

@freezed
sealed class ProxySettings with _$ProxySettings {
  const ProxySettings._();

  const factory ProxySettings.noProxy() = ProxySettings_NoProxy;
  const factory ProxySettings.customProxyList(List<CustomProxy> field0) =
      ProxySettings_CustomProxyList;
}

@freezed
sealed class RedirectSettings with _$RedirectSettings {
  const RedirectSettings._();

  const factory RedirectSettings.noRedirect() = RedirectSettings_NoRedirect;
  const factory RedirectSettings.limitedRedirects(int field0) =
      RedirectSettings_LimitedRedirects;
}

class RustHttpRequest {
  final String method;
  final String url;
  final List<(String, String)>? headers;
  final Emulation? emulation;
  final RedirectSettings? redirectSettings;
  final Uint8List? bodyBytes;
  final HttpVersionPref? httpVersionPref;
  final TimeoutSettings? timeoutSettings;
  final bool? throwOnStatusCode;
  final ProxySettings? proxySettings;
  final TlsSettings? tlsSettings;
  final DnsSettings? dnsSettings;
  final String? userAgent;

  const RustHttpRequest({
    required this.method,
    required this.url,
    this.headers,
    this.emulation,
    this.redirectSettings,
    this.bodyBytes,
    this.httpVersionPref,
    this.timeoutSettings,
    this.throwOnStatusCode,
    this.proxySettings,
    this.tlsSettings,
    this.dnsSettings,
    this.userAgent,
  });

  @override
  int get hashCode =>
      method.hashCode ^
      url.hashCode ^
      headers.hashCode ^
      emulation.hashCode ^
      redirectSettings.hashCode ^
      bodyBytes.hashCode ^
      httpVersionPref.hashCode ^
      timeoutSettings.hashCode ^
      throwOnStatusCode.hashCode ^
      proxySettings.hashCode ^
      tlsSettings.hashCode ^
      dnsSettings.hashCode ^
      userAgent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustHttpRequest &&
          runtimeType == other.runtimeType &&
          method == other.method &&
          url == other.url &&
          headers == other.headers &&
          emulation == other.emulation &&
          redirectSettings == other.redirectSettings &&
          bodyBytes == other.bodyBytes &&
          httpVersionPref == other.httpVersionPref &&
          timeoutSettings == other.timeoutSettings &&
          throwOnStatusCode == other.throwOnStatusCode &&
          proxySettings == other.proxySettings &&
          tlsSettings == other.tlsSettings &&
          dnsSettings == other.dnsSettings &&
          userAgent == other.userAgent;
}

class RustHttpResponse {
  final int status;
  final List<(String, String)> headers;
  final Uint8List body;

  const RustHttpResponse({
    required this.status,
    required this.headers,
    required this.body,
  });

  @override
  int get hashCode => status.hashCode ^ headers.hashCode ^ body.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustHttpResponse &&
          runtimeType == other.runtimeType &&
          status == other.status &&
          headers == other.headers &&
          body == other.body;
}

class TimeoutSettings {
  final Duration? timeout;
  final Duration? connectTimeout;
  final Duration? keepAliveTimeout;
  final Duration? keepAlivePing;

  const TimeoutSettings({
    this.timeout,
    this.connectTimeout,
    this.keepAliveTimeout,
    this.keepAlivePing,
  });

  @override
  int get hashCode =>
      timeout.hashCode ^
      connectTimeout.hashCode ^
      keepAliveTimeout.hashCode ^
      keepAlivePing.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TimeoutSettings &&
          runtimeType == other.runtimeType &&
          timeout == other.timeout &&
          connectTimeout == other.connectTimeout &&
          keepAliveTimeout == other.keepAliveTimeout &&
          keepAlivePing == other.keepAlivePing;
}

class TlsSettings {
  final bool trustRootCertificates;
  final List<Uint8List> trustedRootCertificates;
  final bool verifyCertificates;
  final TlsVersion? minTlsVersion;
  final TlsVersion? maxTlsVersion;
  final bool sni;

  const TlsSettings({
    required this.trustRootCertificates,
    required this.trustedRootCertificates,
    required this.verifyCertificates,
    this.minTlsVersion,
    this.maxTlsVersion,
    required this.sni,
  });

  @override
  int get hashCode =>
      trustRootCertificates.hashCode ^
      trustedRootCertificates.hashCode ^
      verifyCertificates.hashCode ^
      minTlsVersion.hashCode ^
      maxTlsVersion.hashCode ^
      sni.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TlsSettings &&
          runtimeType == other.runtimeType &&
          trustRootCertificates == other.trustRootCertificates &&
          trustedRootCertificates == other.trustedRootCertificates &&
          verifyCertificates == other.verifyCertificates &&
          minTlsVersion == other.minTlsVersion &&
          maxTlsVersion == other.maxTlsVersion &&
          sni == other.sni;
}

enum TlsVersion { tls12, tls13 }
